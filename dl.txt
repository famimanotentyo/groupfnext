.\venv\Scripts\activate
pip install google-generativeai

from django.db import models
from django.contrib.auth.models import AbstractBaseUser, PermissionsMixin, BaseUserManager
from django.utils import timezone

# ==========================================
# 1. カスタムユーザーマネージャー
# ==========================================
class CustomUserManager(BaseUserManager):
    def create_user(self, employee_number, email, password=None, **extra_fields):
        if not employee_number:
            raise ValueError('社員番号は必須です')
        email = self.normalize_email(email)
        user = self.model(employee_number=employee_number, email=email, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, employee_number, email, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
        extra_fields.setdefault('role', 'admin') # 管理者権限

        return self.create_user(employee_number, email, password, **extra_fields)


# ==========================================
# 2. グループ (部署)
# ==========================================
class Department(models.Model):
    name = models.CharField(max_length=50, verbose_name="グループ名(部署名)")
    description = models.TextField(blank=True, verbose_name="説明")

    def __str__(self):
        return self.name

    class Meta:
        verbose_name = "グループ"
        verbose_name_plural = "グループ"


# ==========================================
# 3. アカウント (User)
# ==========================================
class User(AbstractBaseUser, PermissionsMixin):
    """
    社員番号でログインするカスタムユーザーモデル
    """
    ROLE_CHOICES = [
        ('admin', '管理者'),       # 全機能OK
        ('manager', 'マネージャー'), # 部下の管理OK
        ('employee', '一般社員'),    # 自分のタスクのみ
    ]

    # 社員番号 (ログインIDとして使用)
    employee_number = models.CharField(max_length=20, unique=True, verbose_name="社員番号", help_text="例: 000-000-000")
    
    # 基本情報
    last_name = models.CharField(max_length=50, verbose_name="姓")
    first_name = models.CharField(max_length=50, verbose_name="名")
    last_name_kana = models.CharField(max_length=50, verbose_name="セイ")
    first_name_kana = models.CharField(max_length=50, verbose_name="メイ")
    email = models.EmailField(unique=True, verbose_name="メールアドレス")
    phone_number = models.CharField(max_length=15, blank=True, null=True, verbose_name="電話番号")
    
    # 所属グループ（部署）
    department = models.ForeignKey(Department, on_delete=models.SET_NULL, null=True, blank=True, verbose_name="所属グループ")
    
    # 役割・権限
    role = models.CharField(max_length=10, choices=ROLE_CHOICES, default='employee', verbose_name="権限")
    
    # 日付情報
    birth_date = models.DateField(null=True, blank=True, verbose_name="生年月日")
    hire_date = models.DateField(null=True, blank=True, verbose_name="入社日")
    date_joined = models.DateTimeField(default=timezone.now, verbose_name="登録日")

    # 1. 初回セットアップが完了したかどうか
    # False = 仮登録状態（管理者が作成した直後）
    # True  = 本登録完了（社員がログインして情報を入力した後）
    is_initial_setup_completed = models.BooleanField(default=False, verbose_name="初回設定完了")

    # 2. 仮パスワードの有効期限
    # 管理者が作成した日時から「1週間後」などがセットされる想定
    temp_password_expires_at = models.DateTimeField(null=True, blank=True, verbose_name="仮パスワード有効期限")
    
    # システム管理用フィールド
    is_active = models.BooleanField(default=True, verbose_name="有効")
    is_staff = models.BooleanField(default=False, verbose_name="管理サイトアクセス権限")

    objects = CustomUserManager()

    USERNAME_FIELD = 'employee_number'
    REQUIRED_FIELDS = ['email', 'last_name', 'first_name']

    class Meta:
        verbose_name = "ユーザー"
        verbose_name_plural = "ユーザー"

    def __str__(self):
        return f"{self.last_name} {self.first_name} ({self.employee_number})"

    # 動的に得意タグを取得するメソッド
    def get_completed_tags(self):
        # 自分が完了に関わったタスクからタグを取得
        return Tag.objects.filter(tasks__completed_users=self).distinct()

    # =================================================
    # ★追加: 有効期限チェック用の便利メソッド
    # =================================================
    def is_temp_password_active(self):
        """
        仮登録状態かつ、有効期限内かどうかを判定する
        """
        # 既に本登録済みなら期限は関係なし
        if self.is_initial_setup_completed:
            return True
            
        # 仮登録状態で、期限が設定されている場合
        if self.temp_password_expires_at:
            return timezone.now() < self.temp_password_expires_at
            
        # 期限設定がない場合は有効とする（運用次第）
        return True
# ==========================================
# 4. タグ (Tag)
# ==========================================
class Tag(models.Model):
    name = models.CharField(max_length=50, unique=True, verbose_name="タグ名")

    def __str__(self):
        return self.name

    class Meta:
        verbose_name = "タグ"
        verbose_name_plural = "タグ"
        ordering = ['name']


# ==========================================
# 5. タスク (Task)
# ==========================================
class Task(models.Model):
    title = models.CharField(max_length=200, verbose_name="タスク名")
    due_date = models.DateTimeField(verbose_name="期限")
    
    # タグ (M2M)
    tags = models.ManyToManyField(Tag, blank=True, related_name='tasks', verbose_name="タグ")
    
    STATUS_CHOICES = [
        ('unstarted', '未着手'),
        ('in_progress', '取り掛かり中'),
        ('pending_review', '確認待ち'),
        ('completed', '完了'),
    ]
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='unstarted', verbose_name="タスク状態")
    
    # 担当者 (M2M)
    assigned_users = models.ManyToManyField(User, related_name='assigned_tasks', blank=True, verbose_name="取り掛かり中の人")
    
    # 完了した人 (M2M)
    completed_users = models.ManyToManyField(User, related_name='completed_tasks', blank=True, verbose_name="完了とした人")

    notes = models.TextField(blank=True, verbose_name="タスク備考欄")
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="作成日時")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="更新日時")

    def __str__(self):
        return self.title

    class Meta:
        verbose_name = "タスク"
        verbose_name_plural = "タスク"
        ordering = ['due_date', 'status']


# ==========================================
# 6. 社内チャット (雑談・連絡用)
# ==========================================
class ChatRoom(models.Model):
    name = models.CharField(max_length=100, blank=True, verbose_name="ルーム名")
    participants = models.ManyToManyField(User, related_name='chat_rooms', verbose_name="参加者")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="最終更新日時")

    def __str__(self):
        return self.name or "チャットルーム"

class ChatMessage(models.Model):
    room = models.ForeignKey(ChatRoom, on_delete=models.CASCADE, related_name='messages')
    sender = models.ForeignKey(User, on_delete=models.CASCADE, related_name='sent_chat_messages')
    content = models.TextField(verbose_name="メッセージ内容")
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['created_at']


# ==========================================
# 7. 業務Q&Aチャット & ナレッジ
# ==========================================
class Consultation(models.Model):
    """
    「詳しい人に質問する」ための専用チャットセッション
    """
    STATUS_CHOICES = [
        ('open', '解決中'),
        ('resolved', '解決済み'),
    ]

    title = models.CharField(max_length=200, verbose_name="相談タイトル")
    requester = models.ForeignKey(User, on_delete=models.CASCADE, related_name='requested_consultations', verbose_name="質問者")
    respondent = models.ForeignKey(User, on_delete=models.CASCADE, related_name='responded_consultations', verbose_name="回答者")
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='open', verbose_name="状態")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.title} ({self.requester} -> {self.respondent})"

class ConsultationMessage(models.Model):
    consultation = models.ForeignKey(Consultation, on_delete=models.CASCADE, related_name='messages')
    sender = models.ForeignKey(User, on_delete=models.CASCADE)
    content = models.TextField(verbose_name="メッセージ内容")
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['created_at']

class Question(models.Model):
    """
    Consultation解決後にGeminiが生成するナレッジ
    """
    source_consultation = models.OneToOneField(Consultation, on_delete=models.SET_NULL, null=True, blank=True, verbose_name="元チャット")
    title = models.CharField(max_length=200, verbose_name="質問タイトル(要約)")
    problem_summary = models.TextField(verbose_name="課題・質問内容")
    solution_summary = models.TextField(verbose_name="解決策・操作手順")
    tags = models.ManyToManyField(Tag, blank=True, related_name='questions', verbose_name="関連タグ")
    created_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, verbose_name="作成者")
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.title

    class Meta:
        verbose_name = "ナレッジ(解決済質問)"
        verbose_name_plural = "ナレッジ(解決済質問)"


# ==========================================
# 8. マニュアル (Manual)
# ==========================================
class Manual(models.Model):
    """
    業務マニュアル（承認フロー & 閲覧制限付き）
    """
    STATUS_CHOICES = [
        ('pending', '承認待ち'),
        ('approved', '公開中'),
        ('rejected', '差戻し'),
    ]
    VISIBILITY_CHOICES = [
        ('public', '全社員に公開'),
        ('manager_only', '管理職(Manager以上)のみ'),
        ('department_only', '自部署のみ'), 
    ]

    title = models.CharField(max_length=100, verbose_name="マニュアル名")
    description = models.TextField(blank=True, verbose_name="説明・備考")
    file = models.FileField(upload_to='manuals/', verbose_name="ファイル")
    
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='pending', verbose_name="状態")
    visibility = models.CharField(max_length=20, choices=VISIBILITY_CHOICES, default='public', verbose_name="公開範囲")
    
    created_by = models.ForeignKey(User, on_delete=models.CASCADE, related_name='created_manuals', verbose_name="作成者")
    approved_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True, related_name='approved_manuals', verbose_name="承認者")
    department = models.ForeignKey(Department, on_delete=models.SET_NULL, null=True, blank=True, verbose_name="関連部署")

    created_at = models.DateTimeField(auto_now_add=True, verbose_name="作成日時")
    approved_at = models.DateTimeField(null=True, blank=True, verbose_name="承認日時")

    def __str__(self):
        return self.title

    class Meta:
        verbose_name = "マニュアル"
        verbose_name_plural = "マニュアル"
        ordering = ['-created_at']


# ==========================================
# 9. スケジュール (ScheduleEvent)
# ==========================================
class ScheduleEvent(models.Model):
    """
    カレンダーに表示する「タスク以外の予定」
    """
    EVENT_TYPE_CHOICES = [
        ('meeting', '会議'),
        ('outing', '外出'),
        ('vacation', '休暇'),
        ('other', 'その他'),
    ]

    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='schedule_events', verbose_name="ユーザー")
    title = models.CharField(max_length=100, verbose_name="予定タイトル")
    description = models.TextField(blank=True, verbose_name="詳細")
    
    start_at = models.DateTimeField(verbose_name="開始日時")
    end_at = models.DateTimeField(verbose_name="終了日時")
    
    event_type = models.CharField(max_length=20, choices=EVENT_TYPE_CHOICES, default='other', verbose_name="種類")
    is_private = models.BooleanField(default=False, verbose_name="非公開")

    def __str__(self):
        return f"{self.title} ({self.user})"

    class Meta:
        verbose_name = "スケジュール"
        verbose_name_plural = "スケジュール"


# ==========================================
# 10. 面談日 (Interview)
# ==========================================
class Interview(models.Model):
    manager = models.ForeignKey(User, on_delete=models.CASCADE, related_name='conducted_interviews', verbose_name="担当上司")
    employee = models.ForeignKey(User, on_delete=models.CASCADE, related_name='received_interviews', verbose_name="対象部下")
    
    scheduled_at = models.DateTimeField(verbose_name="面談日時")
    end_at = models.DateTimeField(verbose_name="終了日時", null=True, blank=True)
    
    notes = models.TextField(blank=True, verbose_name="面談メモ")
    
    STATUS_CHOICES = [
        ('tentative', '仮予約(承認待ち)'),
        ('confirmed', '確定'),
        ('rejected', '拒否/再調整'),
        ('completed', '完了'),
        ('cancelled', '中止'),
    ]
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='tentative', verbose_name="状態")

    def __str__(self):
        return f"面談: {self.manager} - {self.employee}"

    class Meta:
        verbose_name = "面談"
        verbose_name_plural = "面談"


# ==========================================
# 11. 通知 (Notification)
# ==========================================
class Notification(models.Model):
    """
    ユーザーへの通知
    POP表示に対応するため、通知の種類と対象IDを保持する
    """
    TYPE_CHOICES = [
        ('info', '一般通知'),             
        ('interview_invite', '面談依頼'), 
        ('task_assign', 'タスク割当'),    
        ('manual_approval', 'マニュアル承認依頼'), 
    ]

    recipient = models.ForeignKey(User, on_delete=models.CASCADE, related_name='notifications', verbose_name="通知先")
    title = models.CharField(max_length=100, verbose_name="タイトル")
    message = models.TextField(verbose_name="本文")
    
    notification_type = models.CharField(max_length=30, choices=TYPE_CHOICES, default='info', verbose_name="通知タイプ")
    related_object_id = models.IntegerField(null=True, blank=True, verbose_name="関連ID")
    link_url = models.CharField(max_length=200, blank=True, null=True, verbose_name="リンクURL")
    
    is_read = models.BooleanField(default=False, verbose_name="既読")
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="通知日時")

    def __str__(self):
        return f"{self.title} -> {self.recipient}"

    class Meta:
        verbose_name = "通知"
        verbose_name_plural = "通知"
        ordering = ['-created_at']